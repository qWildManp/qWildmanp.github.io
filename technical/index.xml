<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Technicals on Langxuan(Harry) He</title><link>https://qwildmanp.github.io/technical/</link><description>Recent content in Technicals on Langxuan(Harry) He</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 21 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://qwildmanp.github.io/technical/index.xml" rel="self" type="application/rss+xml"/><item><title>Procedual Generate Level: Deadly Game</title><link>https://qwildmanp.github.io/technical/work1/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://qwildmanp.github.io/technical/work1/</guid><description>It is a procedural generated map tech approach
Procedual Level Gnertator Level Generation-Prototype
Level Generation-Final
Basic Approach Procedural generated map. the number of rooms in each sub-level is certain, but the selection and arrangement of room types are randomly distributed. I use scriptable file to store the room requirements of each sub-level. The generation process uses scriptable to traverse each sublevel one by one to ensure that the sublevels are generated in order.</description></item><item><title>Traditional Animation : Inverse Kenematic</title><link>https://qwildmanp.github.io/technical/work3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qwildmanp.github.io/technical/work3/</guid><description>Procedual Animation using Jacobian Approach
Goal Implement two procedural animation techniques (CCD and Transpose Jacobian) Compare results between two methods
Technique - CCD Cyclic Coordinate Descent Inverse Kinematics
Main idea: align one joint with the end effector and the target at a time, so that the last bone of the chain iteratively gets closer to the target.
Algorithm: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Target T (x_t,y_t); End Effecter E (x_e,y_e); Joint J(x_j,y_j) dis(T,E) WHILE(dis(T,E) is not close enough) DO Vector3 normalized(JT); Vector3 normalized(JE); Quat q = Compute rotation quaternion from JE -&amp;gt; JT; apply quaternion rotation to current joint J; Update new dis(T,E); IF current J is root joint DO reset to first joint; ELSE change current J to upper joint; END IF	dis(T,E) END WHILE Video: Technique â€“ Jacobian Transpose IK(3DOF)(Numerical Approach) Main idea : Jacobian Matrix $ ğ½âˆ† \theta= âˆ†ğ‘’ $ $ ğ½^{âˆ’1}ğ½âˆ† \theta = ğ½^{âˆ’1}âˆ†ğ‘’ $ $ âˆ† \theta= ğ½^{âˆ’1}âˆ†ğ‘’ =&amp;gt; ğ½^Tâˆ†ğ‘’ $ Algorithm: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 Target T (x_t,y_t); End Effecter E (x_e,y_e); Joint J(x_j,y_j) dis(T,E) dynamic scaler Alpha matrix delta_theta(9, 1);	matrix delta_e(3, 1); delta_e.</description></item></channel></rss>